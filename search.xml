<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSP2019游记]]></title>
    <url>%2F2019%2F11%2F13%2FCSP2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[RP++! Day -2一想到这周六就csp了就感觉一阵紧张，干脆先提前占个坑 感觉今年整一年都浪费了。。感觉现在水平也没比去年今天高多少。。都已经被cyz和tbr吊打几条街了！（Orz两位咕值rank前5） 不过其实心态比去年要好一点吧。毕竟OI看起来已经走不通了，再往后就只能是爱好了。再考其实也只是觉得没拿到省一确实可惜。没拿到省一的影响倒是没有去年那么大了。如果考得好可能会去apio或冬令营（如果能去）玩玩，不然下篇游记有可能就是2021高考游记了QAQ。 这几天还是尽量刷刷板子吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识点总结]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[关于联赛-&gt;省选的一些知识点 数据结构链表(8) *DLX()队列(8) 单调队列(8) 栈(8) 单调栈(√)堆(8) 可并堆(5) 可持久化可并堆()并查集(7) 带权并查集()Huffman树()树状数组(5) 二维树状数组()线段树(7) 二维线段树() 线段树合并(6) 线段树分治() 可持久化线段树(√)扫描线(2)平衡树(5) 平衡树合并() 树套树() LCT() Top tree()CDQ分治(4) 整体二分(4)虚树()分块(6) 莫队(7) 树上莫队() 块状链表() *可持久化块状链表()树链剖分(7) 长链剖分() dsu_on_tree() 字符串hash(7)KMP(6) 扩展KMP() AC自动机()trie(7) 01trie() 可持久化trie()manachar(2) 回文自动机()后缀数组() 后缀树() 后缀自动机() 图论dfs(7) bf(7) a*()prim(8) kruskal(8) kruskal重构树()最短路(7) 次短路(2) k短路()dij(8) spfa(8) floyd(5)强连通分量(8) 点双() 边双() 割点() 割边()朱刘()差分约束(4)欧拉图() 二分图(7)最大团() 最大独立集()最大流(6) 最小割(4) 费用流(2) 上下界()0/1分数规划() 2-sat()树的直径() 重心() 点分治() 边分治() 基环树()树链剖分(7) 长链剖分() dsu_on_tree() 数论gcd(4) exgcd(2)线性筛()逆元() 各种定理() 龟速乘()卡特兰数(2) 斯特林数()组合数学() 容斥() lucas定理() exlucas()矩阵加速(3) 矩阵树定理()概率与期望() 博弈论() SG函数()拉格朗日插值法() 牛顿迭代() 高斯消元()CRT() exCRT()*辛普森积分()整除分块()欧拉函数() 莫比乌斯函数() 狄利克雷卷积() 莫比乌斯反演()FFT() NTT() FWT() 多项式相关()杜教筛()BSGS() exBSGS() 计算几何计算几何初步()(Menci)凸包() 动态凸包()三角剖分() 梯形剖分()旋转卡壳() 半平面交() 圆的反演()pick定理() 扫描线() 动态规划背包(5) 树形(4) 记搜(4) 悬线法()区间(4) 多维(3) 状压(5) 数位(2)矩阵加速(3) 单调队列优化(4) 斜率优化(4) 四边形不等式优化()斯坦纳树(2) 插头() DP套DP() 动态DP() ##其他 贪心(3)倍增(4)meet_in_the_middle()模拟退火() 遗传()STL(6)]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈整体二分和CDQ分治]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E5%92%8CCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[你：“woc这个树套树细节怎么这么多？” 某dalao：“什么题让我看一看……这不cdq裸题吗？” 你：“???…” 你：“woc这三百行的代码怎么调啊？” 某dalao：“emmm，我的才一百不到啊？” 你：“???求教怎么写的” 某dalao：“整体二分直接做啊” 你：“???…” 整体二分前置知识:二分答案(等于没说) 先来看一道经典题吧 k-th num题意：给你一个序列，每次询问一个子序列内的第k大的值 我们先来看如果只有一次询问该怎么做。 考虑使用二分答案二分出答案域$[l, r]$，该怎么检查？ 可以直接暴力扫一遍区间，统计一下大小在$[l, mid]$里面的个数，如果大于$k$的话就说明答案一定在$[l, mid]$里面，令$r = mid$，继续二分。假如大小在$[l, mid]$里面的个数小于$k$，就说明答案在$[mid+1, r]$里面，令$l = mid+1$继续二分即可。 以上的二分都是基础，想必大家都是没什么问题。 但是如果想要多组询问该怎么做呢？肯定不能每组询问都扫一遍，]]></content>
      <categories>
        <category>分治</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二分</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈权值线段树与可持久化线段树]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[我们先从一道经典题来入手吧 你需要维护一个数据结构，支持插入一个数，以及询问当前第k大的数是什么我们用平衡树自然是可以做的，但有没有别的更简单的做法呢？ 我们考虑类比平衡树，用线段树解决。平衡树为什么可以做？因为他它证了当前节点左儿子比他小，右儿子比他大，并且维护了每个节点的size，所以可以找到k大。那我们想用线段树该怎么做呢？ 这里我们转换一下思路，用每个叶子节点记录下当前自然数出现的次数。例如当前某个叶子节点管理的区间是[3,3],那么他记录的就是3这个自然数当前出现的次数。那么对于任意一个节点管理的区间是lr，那么他记录的就是自然数lr一共出现了多少次。 我们每次插入就是相当于线段树上单点修改。查询k大的操作类比一下平衡树就行了。 这种线段树被称作权值线段树。权值线段树有什么好的呢？但我们再观察观察，就可以发现一个非常惊人的事情，两颗权值线段树可以类似前缀和直接做减法！！比如我们用插入了b以后的权值线段树减去插入a之前的权值线段树得到的权值线段树，得到的权值线段树就相当于只插入a到b之间的数的权值线段树！！我们可以用这个性质干什么呢？某些读者可能已经想到了。区间K大！！！ 这种类似前缀和用权值线段树的东西就叫做可持久化线段树，也叫主席树。关于主席树的详解强烈推荐孤独·粲泽dalao的博客 带修的主席树也不难，如果我们朴素的用类似前缀和的修改的话复杂度是$O(n log n)$的。 那么有没有更快一点的修改速度呢？有。树状数组。 其实树状数组本质就是用一个正整数关于二的不重复次幂的唯一分解性质优化前缀和，使查询与修改都变成了$O(log n)$ 主席树就像一颗颗权值线段树的前缀和，我们也可以用树状数组优化他，使得查询与修改复杂度都变为$O((log n)^2)。]]></content>
      <categories>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈可并堆-启发式合并-左偏树]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[普通的二叉堆是一颗完全二叉树，可以支持$O(1)$的查询当前堆内min/max，$O(log n)$的插入和删除节点。他支不支持合并呢？ 我们可以首先改变一下堆的写法，把他用一种类似BST(二叉搜索树)的写法写出来，就可以有一种合并的方法！ 先用文字描述一下：假设我们要将x和y这两个小根堆合并，我们判断一下如果x的堆顶大于y的堆顶，就交换一下x和y，然后继续合并x的某个子孩子和y。 没看懂上面那一段文字也没关系，我们上图：(图取自教练上课时的课件，应该没关系吧QAQ) 假设我们要合并这两棵树 继续往下合并 这次合并我们发现x的堆顶大于y的堆顶了，就交换了x和y，然后继续往下合并 最后我们发现7没有右儿子，就直接让7的右儿子变成y就行了！！ 到此，合并正式完成！ 但是我们发现这样合并完之后，堆并不再是一颗完全二叉树了，那怎么办呢？ 这里就我们可以用一种贪心的思想。其实就是我之前说的继续合并x的某个儿子与y。究竟是哪个儿子呢？ 我们这里定义一个值，叫做”根值”，一个节点的根值就是它到最近的叶子节点的距离。其实之前那几张图上每个节点左上角的值就是这个点的根值。 那么我们每次合并就只要合并x的根值最小的儿子和y就行了。这就叫做启发式合并(貌似)。是不是跟并查集的按秩合并有点像啊! 关于他的复杂度，我们可以感性理解为O(两个堆的堆顶的根值)，而用这种启发式合并的话，即使根值最坏也就是$logn$的(完全二叉树)，所以合并一次的复杂度就是$O(log n)$的辣！ 那么左偏树又是什么呢？其实就是保证它的右儿子的根值比作儿子小，然后每次合并就只用合并x的右儿子和y就行了！同时回溯的时候发现不满足左偏树性质时就交换左右儿子(感觉没什么用啊) 插入 就是合并一个堆和一个只有一个点的堆。 删除 直接合并它的左右儿子就行了 查询堆顶 直接返回堆顶就行了 关于启发式合并那一块是学了左偏树之后自己YY的，不知道是否叫这个啊？还是有什么别的名字？各位dalao轻喷啊QAQ 下面贴代码吧！指针党福利！(有想看指针版treap的可以去我的题解里) 启发式合并：(通过Luogu P3377,用时405ms) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define DEBUG printf("PassLine:%d\n", __LINE__)using namespace std;const int maxn = 1e5+10; struct left_heap&#123; int dist, val, idx; left_heap *ls, *rs, *fa; left_heap()&#123; dist = val = idx = 0; ls = rs = fa = NULL; &#125;&#125;;int n, m, exist[maxn];left_heap *tr[maxn];left_heap *getf(left_heap *x)&#123;//找到x所属的堆的根 while(x-&gt;fa != NULL &amp;&amp; x!=NULL) x = x-&gt;fa; return x;&#125;left_heap *merge(left_heap *x, left_heap *y)&#123; if(x == NULL) return y; if(y == NULL) return x; if(x-&gt;val &gt; y-&gt;val || (x-&gt;val == y-&gt;val &amp;&amp; x-&gt;idx &gt; y-&gt;idx)) swap(x, y);//如果x的堆顶的值大于y的堆顶，就交换两个堆 if(x-&gt;ls == NULL) x-&gt;ls = merge(x-&gt;ls, y); else if(x-&gt;rs == NULL) x-&gt;rs = merge(x-&gt;rs, y); else if(x-&gt;ls-&gt;dist &lt; x-&gt;rs-&gt;dist) x-&gt;ls = merge(x-&gt;ls, y);//左儿子的根值比右儿子小就继续合并左儿子和y else x-&gt;rs = merge(x-&gt;rs, y);//否则合并右儿子和y if(x-&gt;ls != NULL) x-&gt;ls-&gt;fa = x; if(x-&gt;rs != NULL) x-&gt;rs-&gt;fa = x; if(x-&gt;ls == NULL || x-&gt;rs == NULL) x-&gt;dist = 0; else x-&gt;dist = min(x-&gt;ls-&gt;dist, x-&gt;rs-&gt;dist)+1;//更新x的根值 return x;&#125;int pop(left_heap *x)&#123; int t = x-&gt;val; if(x-&gt;ls != NULL)x-&gt;ls-&gt;fa = NULL; if(x-&gt;rs != NULL)x-&gt;rs-&gt;fa = NULL; if(x-&gt;ls != NULL &amp;&amp; x-&gt;rs != NULL)merge(x-&gt;ls, x-&gt;rs);//合并左右儿子 exist[x-&gt;idx] = true; delete x;//直接在内存中删除x，以防后患+节约内存 return t;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int t; for(int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; t; left_heap *la = new left_heap; la-&gt;val = t; la-&gt;idx = i; tr[i] = la; &#125; int opt, x, y; for(int i=1; i&lt;=m; i++)&#123; cin &gt;&gt; opt; if(opt == 1)&#123;//合并操作 cin &gt;&gt; x &gt;&gt; y; if(exist[x] || exist[y]) continue; if(x == y) continue; left_heap *fx = getf(tr[x]), *fy = getf(tr[y]);//找到两个堆的根 if(fx == fy) continue; merge(fx, fy);//合并 &#125; if(opt == 2)&#123; cin &gt;&gt; x; if(exist[x] || exist[getf(tr[x])-&gt;idx])&#123;cout &lt;&lt; -1 &lt;&lt; endl;continue;&#125; else cout &lt;&lt; pop(getf(tr[x])) &lt;&lt; endl; &#125; &#125;&#125; 左偏树：(通过Luogu P3377, 用时363ms) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define DEBUG printf("PassLine:%d\n", __LINE__)using namespace std;const int maxn = 1e5+10; struct left_heap&#123; int dist, val, idx; left_heap *ls, *rs, *fa; left_heap()&#123; dist = val = idx = 0; ls = rs = fa = NULL; &#125;&#125;;int n, m, exist[maxn];left_heap *tr[maxn];left_heap *getf(left_heap *x)&#123; while(x-&gt;fa != NULL &amp;&amp; x!=NULL) x = x-&gt;fa; return x;&#125;left_heap *merge(left_heap *x, left_heap *y)&#123; if(x == NULL) return y; if(y == NULL) return x; if(x-&gt;val &gt; y-&gt;val || (x-&gt;val == y-&gt;val &amp;&amp; x-&gt;idx &gt; y-&gt;idx)) swap(x, y); x-&gt;rs = merge(x-&gt;rs, y); if(x-&gt;rs != NULL)x-&gt;rs-&gt;fa = x; if(x-&gt;ls == NULL)&#123;x-&gt;ls = x-&gt;rs; x-&gt;rs = NULL;&#125; else if(x-&gt;ls-&gt;dist &lt; x-&gt;rs-&gt;dist) swap(x-&gt;ls, x-&gt;rs);//主要是这一步，如果左儿子比右儿子根值小，就交换左右儿子 x-&gt;dist = (x-&gt;rs == NULL ? 0 : x-&gt;rs-&gt;dist+1); return x;&#125;int pop(left_heap *x)&#123; int t = x-&gt;val; if(x-&gt;ls != NULL)x-&gt;ls-&gt;fa = NULL; if(x-&gt;rs != NULL)x-&gt;rs-&gt;fa = NULL; if(x-&gt;ls != NULL &amp;&amp; x-&gt;rs != NULL)merge(x-&gt;ls, x-&gt;rs); exist[x-&gt;idx] = true; delete x; return t;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int t; for(int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; t; left_heap *la = new left_heap; la-&gt;val = t; la-&gt;idx = i; tr[i] = la; &#125; int opt, x, y; for(int i=1; i&lt;=m; i++)&#123; cin &gt;&gt; opt; if(opt == 1)&#123; cin &gt;&gt; x &gt;&gt; y; if(exist[x] || exist[y]) continue; if(x == y) continue; left_heap *fx = getf(tr[x]), *fy = getf(tr[y]); if(fx == fy) continue; merge(fx, fy); &#125; if(opt == 2)&#123; cin &gt;&gt; x; if(exist[x] || exist[getf(tr[x])-&gt;idx])&#123;cout &lt;&lt; -1 &lt;&lt; endl;continue;&#125; else cout &lt;&lt; pop(getf(tr[x])) &lt;&lt; endl; &#125; &#125;&#125; 最后说几句，可并堆还有好几种，如配对堆，斐波那契堆等等，大家想学的可以去看一看！]]></content>
      <categories>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
